#pragma kernel ScatterKernel

struct Filter
{
    int type;
    float3 v1;
    float3 v2;
    float intensity;
};

StructuredBuffer<int> trianglesBuffer;
StructuredBuffer<float3> verticesBuffer;
StructuredBuffer<float3> normalsBuffer;

AppendStructuredBuffer<float3> scatterBuffer;
AppendStructuredBuffer<float3> directionBuffer;
AppendStructuredBuffer<float3> randomizeBuffer;

int _FilterCount;
StructuredBuffer<Filter> filtersBuffer;

float4x4 _TransformMatrix;

int _FaceCount;
float _Density;
float _Seed;

float rnd1To1(float seed)
{
    return frac(sin(dot(float2(seed, sin(seed)), float2(12.9898, 78.233))) * 43758.5453);
}
float2 rnd1To2(float seed)
{
    float x = rnd1To1(seed);
    float y = rnd1To1(x);
    return float2(x, y);
}
float3 rnd1To3(float seed)
{
    float x = rnd1To1(seed);
    float y = rnd1To1(x);
    float z = rnd1To1(y);
    return float3(x, y, z);
}
float rnd2To1(float2 seed)
{
    return frac(sin(dot(seed, float2(12.9898, 78.233))) * 43758.5453);
}
float2 rand2To2(in float2 uv) 
{
    float noiseX = (frac(sin(dot(uv, float2(12.9898,78.233) * 2.0)) * 43758.5453));
    float noiseY = sqrt(1 - noiseX * noiseX);
    return float2(noiseX, noiseY);
}

float3 triangleLerp(float3 a, float3 b, float3 c, float2 t)
{
    if (t.x + t.y > 1)
    {
        t.x = (1 - t.x);
        t.y = (1 - t.y);
    }
    
    float3 abShift = lerp(0, b - a, t.x);
    float3 acShift = lerp(0, c - a, t.y);
    return a + abShift + acShift;
}
float triangleArea(float3 a, float3 b, float3 c)
{
    return (length(a - b) * length(a - c)) / 2;
}

void GetTriangleVertex(int faceIndex, out float3 pA, out float3 pB, out float3 pC)
{
    pA = verticesBuffer[trianglesBuffer[faceIndex + 0]];
    pB = verticesBuffer[trianglesBuffer[faceIndex + 1]];
    pC = verticesBuffer[trianglesBuffer[faceIndex + 2]];

    pA = mul(_TransformMatrix, float4(pA, 1)).xyz;
    pB = mul(_TransformMatrix, float4(pB, 1)).xyz;
    pC = mul(_TransformMatrix, float4(pC, 1)).xyz;
}

void GetTriangleNormal(int faceIndex, out float3 nA, out float3 nB, out float3 nC)
{
    nA = normalsBuffer[trianglesBuffer[faceIndex + 0]];
    nB = normalsBuffer[trianglesBuffer[faceIndex + 1]];
    nC = normalsBuffer[trianglesBuffer[faceIndex + 2]];

    float4x4 rotateMat = _TransformMatrix;
    rotateMat._m03_m13_m23 = 0;

    nA = mul(rotateMat, float4(nA, 1)).xyz;
    nB = mul(rotateMat, float4(nB, 1)).xyz;
    nC = mul(rotateMat, float4(nC, 1)).xyz;

}

bool planeClip(Filter filter, float3 position)
{
    float planeDistance = dot(filter.v1, position) - filter.intensity;
    
    return planeDistance < 0;
}
bool directionClamp(Filter filter, float3 direction)
{
    float dirAngle = dot(filter.v1, direction) - filter.intensity;

    return dirAngle < 0;
}
bool scatterFilter(float3 position, float3 direction, float3 randomize)
{
    for(int i = 0; i < _FilterCount; i++)
    {
        Filter filter = filtersBuffer[i];

        switch (filter.type)
        {
            case -1:
                return false;
            
            case 0:
                if(planeClip(filter, position)) return false;
                break;

            case 1:
                if(directionClamp(filter, direction)) return false;
                break;

        }
        // if(filter.type == 0) 
    }
    
    return true;
}

[numthreads(640, 1, 1)]
void ScatterKernel (uint3 id : SV_DispatchThreadID)
{
    if(id.x >= _FaceCount) return;

    int faceID = id.x * 3;

    float3 vertA, vertB, vertC;
    GetTriangleVertex(faceID, vertA, vertB, vertC);

    float3 normalA, normalB, normalC;
    GetTriangleNormal(faceID, normalA, normalB, normalC);

    float area = triangleArea(vertA, vertB, vertC);
    int count = max(1, area * _Density);
    
    for(int i = 0; i < count; i++)
    {
        float seed = (_Seed + i + faceID + 1);

        float2 lerpValue = rnd1To2(seed);
        float3 position = triangleLerp(vertA, vertB, vertC, lerpValue);
        float3 direction = normalize(triangleLerp(normalA, normalB, normalC, lerpValue));
        float3 randomize = rnd1To3(seed);

        if(scatterFilter(position, direction, randomize))
        {
            scatterBuffer.Append(position);
            directionBuffer.Append(direction);
            randomizeBuffer.Append(randomize);
        }
    }
}

